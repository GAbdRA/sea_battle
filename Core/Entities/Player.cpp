#include "Player.h"
#include "D:\Pictures\SeaBATTLE\Menu\Menu.h"

void explosion(Ships* characteristic, int ship_pos[12][24], int plus, int& end) //уничтожение кораблкиков и определение победителя в игре
{
	int A = 0; //переменная для правильной зарисовки границы вокруг взоравнного кораблика
	int B = 13; //переменная, которая будет помогать указывать на нужный кораблик
	int C = 0; //переменная, которая хранит количество уничтоженных корабликов (если = 10, то игра завершается)
	bool alive = false; //переменная с помощью которой мы будем проверять уничтожение корабликов
	for (size_t n = 13; n > 3; n--) //проверяем все номерки корабликов на наличие их в массиве
	{
		for (size_t i = 1; i < 11; i++) //проганяем массив по строчкам
		{
			for (size_t r = 2; r < 22; r++) //проганяем массив по столбцам
			{
				if (ship_pos[i][r] == n) //проверяем, есть ли в массиве хоть один номерок с корабликом
				{
					alive = true; //в случае успеха - кораблик жив/ранен
					i = 11; //меняем значение чтобы перейти к следуещему номерку
					break; //выходим из цикла
				}
			}
		}
		if (alive == false) //если номерок найден не был, то говорим, что кораблик которому был присвоен этот номер уничтожен
		{
			characteristic[B - n + plus].alive = false; //говорим что данный кораблик уничтожен
		}
		else //иначе
		{
			alive = false; //меняем данную переменную на "false", чтобы проверить следующий кораблик
		}
	}
	for (size_t i = plus; i < 10 + plus; i++) //запускаем цикл, в котором будем проверять все кораблики одной команды на уничтожение
	{
		if (i == 0 || i == 10) //для 4-х палубных
		{
			A = 0; //меняем значение переменной для правильной отрисовки
		}
		else if (i == 1 || i == 2 || i == 11 || i == 12)  //для 3-х палубных
		{
			A = 1; //меняем значение переменной для правильной отрисовки
		}
		else if (i > 2 && i < 6 || i > 12 && i < 16)  //для 2-х палубных
		{
			A = 2; //меняем значение переменной для правильной отрисовки
		}
		else  //для 1-о палубных
		{
			A = 3; //меняем значение переменной для правильной отрисовки
		}
		if (characteristic[i].alive == false) //если данный кораблик уничтожен
		{
			if (characteristic[i].horizontal == true) //если он имеет горизонтальное положение
			{
				for (size_t q = 0; q < 3; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
				{
					for (size_t w = 0; w < characteristic[i].deck * 3 + A; w++) //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы "окупировать" уничтоженный кораблик
					{
						ship_pos[characteristic[i].y - 2 + q][characteristic[i].x - 4 + w] = 2; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "2" (промах)
					}
				}
				for (size_t g = 0; g < 2 * characteristic[i].deck; g++) //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы выделить уничтоженный кораблик
				{
					ship_pos[characteristic[i].y - 1][characteristic[i].x - 2 + g] = 3; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "3" (поподание)
				}
			}
			else if (characteristic[i].horizontal == false)  //если он имеет вертикальное положение
			{
				for (size_t q = 0; q < characteristic[i].deck + 2; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
				{
					for (int w = -4; w < 2; w++)  //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы "окупировать" уничтоженный кораблик
					{
						ship_pos[characteristic[i].y - 2 + q][characteristic[i].x + w] = 2; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "2" (промах)
					}
				}
				for (int g = 0; g < characteristic[i].deck; g++) //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы выделить уничтоженный кораблик
				{
					for (int n = -2; n < 0; n++) //выполняем нижеуказаныый код 2 раза так как нам нужно поменять значения в массиве для 2-ух клеточек (одной палубы)
					{
						ship_pos[characteristic[i].y - 1 + g][characteristic[i].x + n] = 3; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "3" (поподание)
					}
				}
			}
			C++; // увеличиваем значение счётчика уничтоженных корабликов на 1
		}
	}
	if (C == 10 && plus == 0) //если все наши кораблики уничтожены
	{
		end = 1; //завершаем игру (поражение)
	}
	else if (C == 10 && plus == 10) //если все кораблики врага уничтожены
	{
		end = 2; //завершаем игру (победа)
	}
	else //иначе
	{
		C = 0; //онулдируем счетчик уничтоженных корабликов
	}
}

void LoadCharactShips(Ships* characteristic) //присвоение палуб в соответствии с номером кораблика
{
	for (size_t i = 0; i < 20; i++) //выполнеям нижеуказанный код 20 раз так как общее количество корабликов равно 20
	{
		if (i == 0 || i == 10) //для 4-х палубных
		{
			characteristic[i].deck = 4; //делаем кораблик с 4-мя палубами
		}
		else if (i > 0 && i <= 2 || i > 10 && i <= 12) //для 3-х палубных
		{
			characteristic[i].deck = 3; //делаем кораблик с 3-мя палубами
		}
		else if (i > 2 && i <= 5 || i > 12 && i <= 15) //для 2-х палубных
		{
			characteristic[i].deck = 2; //делаем кораблик с 2-мя палубами
		}
		else if (i > 5 && i <= 9 || i > 15 && i <= 19) ///для 1-о палубных
		{
			characteristic[i].deck = 1; //делаем кораблик с 1-ой палубой
		}
	}
}

void auto_arrangement(Ships* characteristic, int ship_pos[12][24], int plus) //aвтоматическая расстановка корабликов
{
	int y, x, ship = plus; //переменная для координат и номера кораблика
	while (ship < plus + 10) //выполняем нижеуказанный код до тех пор пока, не будут расставлены все 10 корабликов
	{
		characteristic[ship].horizontal = 0 + rand() % 2; //присваиваем рандомную ориентацию
		y = 2 + rand() % 9, x = (1 + rand() % 9) * 2; //присваиваем рандочные координаты (в рамках игровой зоны)
		if (characteristic[ship].horizontal == false && y + characteristic[ship].deck >= 13)
		//проверяем заденит ли кораблик границу по вертикале при перевороте, если его не отодвинуть
		{
			y -= y + characteristic[ship].deck - 12; //если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
		}
		else if (characteristic[ship].horizontal == true && x + characteristic[ship].deck * 2 >= 24)
		//проверяем заденит ли кораблик границу по вертикале при перевороте, если его не отодвинуть
		{
			x -= (x + characteristic[ship].deck * 2) - 22; //если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
		}
		if (characteristic[ship].horizontal == true && ship_pos[y - 1][x] == 0 && ship_pos[y - 1][x + characteristic[ship].deck * 2 - 2] == 0)
		// проверемя имеет ли кораблик горизонтальное положение и нет ли ничего на позициях куда он будет устанавливаться
		{
			characteristic[ship].x = x + 2, characteristic[ship].y = y; //запоминаем координаты первой палубы у каждого кораблика, чтобы в дальнейшем правильно их взрывать
			for (size_t q = 0; q < 3; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо "окупировать" кораблик чтобы они не стояли вполтную к друг другу
			{
				for (size_t w = 1; w < characteristic[ship].deck * 3 + 1; w++)//выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы "окупировать" уничтоженный кораблик
				{
					ship_pos[y - 2 + q][x - 3 + w] = 1;  //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "1" (окупируемая позиция живого кораблика)
				}
			}
			for (int g = 0; g < 2 * characteristic[ship].deck; g++) //выполнеям нижеуказанный код нужное количество раз (для каждого отдельно считаем), чтобы выделить уничтоженный кораблик
			{
				ship_pos[y - 1][x + g] = 13 - ship + plus;  //меняем значение позиций в двумерном массиве который будем прверять на различные цифорки, на "4-13" (номера корабликов (у каждого свой))
			}
			ship++; //переходим к следующему кораблику
		}
		if (characteristic[ship].horizontal == false && ship_pos[y - 1][x] == 0 && ship_pos[y + characteristic[ship].deck - 2][x] == 0)
		// проверемя имеет ли кораблик горизонтальное положение и нет ли ничего на позициях куда он будет устанавливаться
		{
			characteristic[ship].x = x + 2, characteristic[ship].y = y;//запоминаем координаты первой палубы у каждого кораблика, чтобы в дальнейшем правильно их взрывать
			for (size_t q = 0; q < characteristic[ship].deck + 2; q++)
			{
				for (size_t w = 0; w < 6; w++)
				{
					ship_pos[y - 2 + q][x - 2 + w] = 1; //меняем значение "окупируемых" позиций в двумерном массиве который будем прверять на различные цифорки, на "1" (окупируемая позиция живого кораблика)
				}
			}
			for (int g = 0; g < characteristic[ship].deck; g++)
			{
				for (int n = 0; n < 2; n++) //выполняем нижеуказаныый код 2 раза так как нам нужно поменять занчения в массиве для 2-ух клеточек (одной палубы)
				{
					ship_pos[y - 1 + g][x + n] = 13 - ship + plus; //меняем значение позиций в двумерном массиве который будем прверять на различные цифорки, на "4-13" (номера корабликов (у каждого свой))
				}
			}
			ship++; //переходим к следующему кораблику
		}
	}
}

void setShips(int x, int y, int key, int num, int ship_pos[12][24], Ships* characteristic,bool start){
    do //запускаем цикл в котором при нажатии на ту или иную клавишу будеи делать то или иное дейстивие
		{
			PaintPos(ship_pos, 2, 0); //перерисовываем игровую локации с учетём внесенных изменений (поставили кораблик)
			SetCursor(x, y); //ставим курсор на позицию изменяемых ниже переменных (X, Y)
			setColor(Black, Black); //устанавливаем черный цвет так как таким цветом будет выводиться кораблик
			if (characteristic[num].horizontal == true) //если кораблик имеет горизонтальное положение
			{
				for (size_t i = 0; i < characteristic[num].deck; i++) //запускаем цикл который будет отрисовыввать кораблик с нужным колличеством палуб
				{
					cout << "++"; //2 "+" так как одна клеточка в ширину в игре равна 2-ум клеточкам в ширину в консоли
				}
			}
			else if (characteristic[num].horizontal == false)
			{
				y += characteristic[num].deck; //изменяем позицию по "y" на то сколько палуб у кораблика
				for (size_t i = 0; i < characteristic[num].deck; i++)  //запускаем цикл который будет отрисовыввать кораблик с нужным колличеством палуб
				{
					cout << "++"; //2 "+" так как одна клеточка в ширину в игре равна 2-ум клеточкам в ширину в консоли
					y--; //спускаемся вниз на одну клеточку
					SetCursor(x, y); //устанавливаем позицию на одну клеточку ниже и на изначальное по Х
				}
			}
			key = _getch();//функция возвращает номер нажатой клавиши
			switch (key) //Выполняем различные функции в соответствии с нажатой клавишью
			{
			case Left: //если нажали "Стрелочка влево"
				if (x > 3) //позиция до которой разрешено перемещение в лево
				{
					x -= 2; //меняем значение по Х на -2 так как одна клеточка в игре равна двум в консоли
				}
				break;
			case Right: //если нажали "Стрелочка вправо"
				if (characteristic[num].horizontal == true) //Если кораблик имеет горизонтальное положение
				{
					if (x < 22 - characteristic[num].deck * 2) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
					{
						x += 2; //меняем значение переменной Х на +2 так как одна клеточка в игре равна двум в консоли
					}
				}
				else  //Если кораблик имеет вертикальное положение
				{
					if (x < 20) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
					{
						x += 2; //меняем значение переменной Х на +2 так как одна клеточка в игре равна двум в консоли
					}
				}
				break; //закрыли этот кейс
			case Up: //если нажали "Стрелочка вверх"
				if (y > 2) //позиция до которой разрешено перемещение вверх
				{
					y--;  //меняем значение по Y на -1
				}
				break; //закрыли этот кейс
			case Down: //если нажали "Стрелочка вних"
				if (characteristic[num].horizontal == false) //Если кораблик имеет вертикальное положение
				{
					if (y < 12 - characteristic[num].deck) // проверяем не достиг ли он позиции до которой ему можно передвигаться (так как он 4-х палубный, и его нужно ограничивать на 3 клеточки ранее)
					{
						y++;  //меняем значение по Y на +1
					}
				}
				else
				{
					if (y < 11) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
					{
						y++;  //меняем значение по Y на +1
					}
				}
				break; //закрыли этот кейс
			case Q: //если нажали "Q"
				characteristic[num].horizontal = !characteristic[num].horizontal; //изменяем ориентацию кораблика на противоположную
				if (characteristic[num].horizontal == false && y + characteristic[num].deck >= 13)
					//проверяем заденит ли кораблик границу по вертикале при перевороте, если его не отодвинуть
				{
					y -= y + characteristic[num].deck - 12; //если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
				}
				else if (characteristic[num].horizontal == true && x + characteristic[num].deck * 2 >= 24)
					//проверяем заденит ли кораблик границу по вертикале при перевороте, если его не отодвинуть
				{
					x -= (x + characteristic[num].deck * 2) - 22; //если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
				}
				for (size_t i = 0; i < 10 - num; i++) //изменяем ориентацию так же и для последующих корабликов
				{
					characteristic[num + i].horizontal = characteristic[num].horizontal; // заранее изменяем положение следующего кораблика на то которое мы выбрали сейчас
				}
				break; //закрыли этот кейс
			case Enter: //если нажали "Enter"
				if (characteristic[num].horizontal == true && ship_pos[y - 1][x] == 0 && ship_pos[y - 1][x + characteristic[num].deck * 2 - 2] == 0)
				{
					characteristic[num].x = x + 2, characteristic[num].y = y;
					for (size_t q = 0; q < 3; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
					{
						for (size_t w = 1; w < characteristic[num].deck * 3 + 1; w++) //выполнеям нижеуказанный код 11 раз так как надо чтобы 4-х палубный кораблик полностью окупировался
						{
							ship_pos[y - 2 + q][x - 3 + w] = 1; //меняем значение окупируемых позиций в двумерном массиве который будем прверять на различные цифорки, на "1"
						}
					}
					for (int g = 0; g < 2 * characteristic[num].deck; g++) //выполнеям нижеуказанный код 8 раз так как кораблик 4-х палубный, а одна палуба по горизонатали 2 клеточки
					{
						ship_pos[y - 1][x + g] = 13 - num;  //меняем значение позиций в двумерном массиве который будем прверять на различные цифорки, на "2"
					}
					num++; //переходим к следующему кораблику
				}
				if (characteristic[num].horizontal == false && ship_pos[y - 1][x] == 0 && ship_pos[y + characteristic[num].deck - 2][x] == 0)
				{
					characteristic[num].x = x + 2, characteristic[num].y = y;
					for (size_t q = 0; q < characteristic[num].deck + 2; q++) //выполнеям нижеуказанный код 6 раз так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
					{
						for (size_t w = 0; w < 6; w++) //выполнеям нижеуказанный код 6 раз так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
						{
							ship_pos[y - 2 + q][x - 2 + w] = 1; //меняем значение окупируемых позиций в двумерном массиве который будем прверять на различные цифорки, на "1"
						}
					}
					for (int g = 0; g < characteristic[num].deck; g++) //выполнеям нижеуказанный код 3 раза так как кораблик 3-х палубный
					{
						for (int n = 0; n < 2; n++) //выполняем нижеуказаныый код 2 раза так как нам нужно поменять занчения в массиве для 2-ух клеточек (одной палубы)
						{
							ship_pos[y - 1 + g][x + n] = 13 - num; //меняем значение позиций в двумерном массиве который будем прверять на различные цифорки, на "2"
						}
					}
					num++; //переходим к следующему кораблику
				}
			}
			start = true;//запускаем игру
		} while (num <= 9); //цикл работает до тех пор пока количество расставленных корабликов не равно 10
}
